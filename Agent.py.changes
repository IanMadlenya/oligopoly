--- Agent.py	(original)
+++ Agent.py	(refactored)
@@ -69,8 +69,8 @@
         self.agType=agType
 
         # the agents
-        if common.verbose: print "agent of type", self.agType, \
-               "#", self.number, "has been created at", xPos, ",", yPos
+        if common.verbose: print("agent of type", self.agType, \
+               "#", self.number, "has been created at", xPos, ",", yPos)
 
         gvf.pos[self]=(xPos,yPos)
         if common.nodeNumbersInGraph: common.g_labels[self]=str(number)
@@ -80,15 +80,15 @@
 
     # talk
     def talk(self):
-	    print self.agType, self.number
+	    print(self.agType, self.number)
 
     # reset values, redefining the method of agTools.py in $$slapp$$
     def setNewCycleValues(self):
         # the if is to save time, given that the order is arriving to
         # all the agents (in principle, to reset local variables)
         if not common.agent1existing:
-            print "At least one of the agents has to have number==1"
-            print "Missing that agent, all the agents are resetting common values"
+            print("At least one of the agents has to have number==1")
+            print("Missing that agent, all the agents are resetting common values")
 
         if self.number==1 or not common.agent1existing:
             common.totalProductionInA_TimeStep=0
@@ -126,8 +126,8 @@
         self.numOfWorkers=gvf.nx.degree(common.g, nbunch=self)
         # nbunch : iterable container, optional (default=all nodes)
         # A container of nodes. The container will be iterated through once.
-        print "entrepreneur", self.number, "has", \
-              self.numOfWorkers, "edge/s after hiring"
+        print("entrepreneur", self.number, "has", \
+              self.numOfWorkers, "edge/s after hiring")
 
     def hireFireWithProduction(self):
 
@@ -182,8 +182,8 @@
             self.numOfWorkers=gvf.nx.degree(common.g, nbunch=self)
             # nbunch : iterable container, optional (default=all nodes)
             # A container of nodes. The container will be iterated through once.
-            print "entrepreneur", self.number, "is applying prod. plan and has", \
-                  self.numOfWorkers, "edge/s after hiring"
+            print("entrepreneur", self.number, "is applying prod. plan and has", \
+                  self.numOfWorkers, "edge/s after hiring")
 
         # fire
         if laborForce0 > laborForceRequired:
@@ -212,8 +212,8 @@
             self.numOfWorkers=gvf.nx.degree(common.g, nbunch=self)
             # nbunch : iterable container, optional (default=all nodes)
             # A container of nodes. The container will be iterated through once.
-            print "entrepreneur", self.number, "is applying prod. plan and has", \
-                  self.numOfWorkers, "edge/s after firing"
+            print("entrepreneur", self.number, "is applying prod. plan and has", \
+                  self.numOfWorkers, "edge/s after firing")
 
 
 
@@ -247,8 +247,8 @@
             self.numOfWorkers=gvf.nx.degree(common.g, nbunch=self)
             # nbunch : iterable container, optional (default=all nodes)
             # A container of nodes. The container will be iterated through once.
-            print "entrepreneur", self.number, "has", \
-                  self.numOfWorkers, "edge/s after firing"
+            print("entrepreneur", self.number, "has", \
+                  self.numOfWorkers, "edge/s after firing")
 
 
 
@@ -267,7 +267,7 @@
 
         laborForce=gvf.nx.degree(common.g, nbunch=self) + \
                    1 # +1 to account for the entrepreneur herself
-        print "I'm entrepreneur", self.number, "my laborforce is", laborForce
+        print("I'm entrepreneur", self.number, "my laborforce is", laborForce)
 
         # productivity is set to 1 in the benginning from common space
         self.production = common.laborProductivity * \
@@ -294,7 +294,7 @@
 
         laborForce=gvf.nx.degree(common.g, nbunch=self) + \
                    1 # +1 to account for the entrepreneur herself
-        print "I'm entrepreneur", self.number, "my laborforce is", laborForce
+        print("I'm entrepreneur", self.number, "my laborforce is", laborForce)
 
         # productivity is set to 1 in the benginning from common space
         self.production = common.laborProductivity * \
@@ -474,8 +474,8 @@
         # the entrepreur sells her production, which is cotributing - via
         # totalActualProductionInA_TimeStep, to price formation
         self.profit=common.price * (1.-pv) * self.production - self.costs
-        print "I'm entrepreur", self.number, "my price is ",\
-              common.price * (1.-pv)
+        print("I'm entrepreur", self.number, "my price is ",\
+              common.price * (1.-pv))
 
         common.totalProfit+=self.profit
 
@@ -558,8 +558,8 @@
         myEntrepreneur=gvf.nx.neighbors(common.g, self)[0]
         myEntrepreneurProfit=myEntrepreneur.profit
         if myEntrepreneurProfit >= common.thresholdToEntrepreneur:
-            print "I'm worker %2.0f and myEntrepreneurProfit is %4.2f" %\
-                  (self.number, myEntrepreneurProfit)
+            print("I'm worker %2.0f and myEntrepreneurProfit is %4.2f" %\
+                  (self.number, myEntrepreneurProfit))
             common.g.remove_edge(myEntrepreneur, self)
 
             #originally, it was a worker
@@ -584,8 +584,8 @@
           myEntrepreneurCosts=myEntrepreneur.costs
           if myEntrepreneurProfit/myEntrepreneurCosts  >= \
             common.thresholdToEntrepreneur:
-            print "Worker %2.0f is now an entrepreneur (previous firm relative profit %4.2f)" %\
-                  (self.number, myEntrepreneurProfit/myEntrepreneurCosts)
+            print("Worker %2.0f is now an entrepreneur (previous firm relative profit %4.2f)" %\
+                  (self.number, myEntrepreneurProfit/myEntrepreneurCosts))
             common.g.remove_edge(myEntrepreneur, self)
 
             #originally, it was a worker
@@ -604,15 +604,15 @@
         if self.agType != "entrepreneurs": return
 
         if self.profit <= common.thresholdToWorker:
-            print "I'm entrepreneur %2.0f and my profit is %4.2f" %\
-                  (self.number, self.profit)
+            print("I'm entrepreneur %2.0f and my profit is %4.2f" %\
+                  (self.number, self.profit))
 
 
 
             # the list of the employees of the firm, IF ANY
             entrepreneurWorkers=gvf.nx.neighbors(common.g,self)
-            print "entrepreneur", self.number, "has", len(entrepreneurWorkers),\
-             "workers to be fired"
+            print("entrepreneur", self.number, "has", len(entrepreneurWorkers),\
+             "workers to be fired")
 
             if len(entrepreneurWorkers) > 0:
                 for aWorker in entrepreneurWorkers:
@@ -643,15 +643,15 @@
             return
 
         if self.profit/self.costs <= common.thresholdToWorker:
-            print "I'm entrepreneur %2.0f and my relative profit is %4.2f" %\
-                  (self.number, self.profit/self.costs)
+            print("I'm entrepreneur %2.0f and my relative profit is %4.2f" %\
+                  (self.number, self.profit/self.costs))
 
 
 
             # the list of the employees of the firm, IF ANY
             entrepreneurWorkers=gvf.nx.neighbors(common.g,self)
-            print "entrepreneur", self.number, "has", len(entrepreneurWorkers),\
-             "workers to be fired"
+            print("entrepreneur", self.number, "has", len(entrepreneurWorkers),\
+             "workers to be fired")
 
             if len(entrepreneurWorkers) > 0:
                 for aWorker in entrepreneurWorkers:
@@ -683,8 +683,8 @@
          psiShock=uniform(common.productionCorrectionPsi/2,
                              common.productionCorrectionPsi)
          self.hasTroubles=psiShock
-         print "Entrepreneur", self.number, "is suffering a reduction of "\
-               "production of", psiShock*100, "%, due to work troubles"
+         print("Entrepreneur", self.number, "is suffering a reduction of "\
+               "production of", psiShock*100, "%, due to work troubles")
 
          if common.wageCutForWorkTroubles:
            # the list of the employees of the firm
